<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  Vue的实用指南 |   Mooory-Site </title>

 
  
    <link rel="icon" href="/images/favicon.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-inner">        

    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-logo">
      <a href="/">
        <!--<img class="header-logo-img" src="/images/logo.png"/>-->首页
      </a>
      
    </div>

    <div class="header-menu">          
              
          
            <a class="header-menu-link" id="header-menu-home" href="/">
              <i class="iconfont icon-home">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-archives" href="/archives">
              <i class="iconfont icon-archives">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-tags" href="/tags">
              <i class="iconfont icon-tags">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-about" href="/about">
              <i class="iconfont icon-about">  
            </i></a>     
          
              
          
              <a class="header-menu-link" id="header-menu-search">
                <i class="iconfont icon-search">  
              </i></a>
          
                  
    </div>  
    
  </nav>
</header>

   

      <div class="container">       
          
          
            <div class="container-inner">  
          

          <article class="post">
  
	
<div class="post-header">
	<p class="post-title">	
		vue的实用指南
	</p>

	<div class="post-info">	
		<span class="post-info-entry">
			Jul 08, 2018
		</span>

		
		
			<i class="iconfont icon-words"></i>
			<span class="post-info-entry">14283
			</span>
		
	</div>
</div> 
	
 

	  <div class="typo post-content slideDownMin">

		

			
					<p>本章将介绍vue的常用语法和常见问题，请多多指教~<br><a id="more"></a></p>
<h1 id="基本实用"><a href="#基本实用" class="headerlink" title="基本实用"></a>基本实用</h1><h2 id="常用表达"><a href="#常用表达" class="headerlink" title="常用表达"></a>常用表达</h2><table>
<thead>
<tr>
<th>表达方式</th>
<th style="text-align:center">作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>v-bind:title = ‘message’</td>
<td style="text-align:center">第二种绑定方式，可直接作用在html特性上。 将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致</td>
<td>简写 v-bind:href  ==  :href</td>
</tr>
<tr>
<td>v-if = ‘seen’ v-else</td>
<td style="text-align:center">控制元素是否显示</td>
<td>Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用过渡效果</td>
</tr>
<tr>
<td>v-for = ‘todo in todos’</td>
<td style="text-align:center">循环数组进行显示</td>
<td>在控制台里，输入 app4.todos.push({ text: ‘新项目’ })可以往数组新增数据</td>
</tr>
<tr>
<td>v-on:click=’event’</td>
<td style="text-align:center">添加事件监听器</td>
<td>methods: { event: function () { this.message = this.message.split(‘’).reverse().join(‘’) } }      简写 v-on:click == @click</td>
</tr>
<tr>
<td>v-modal=’message’</td>
<td style="text-align:center">实现表单输入和应用状态之间的双向绑定</td>
<td>&lt;input v-model=”message”></td>
</tr>
<tr>
<td>v-once</td>
<td style="text-align:center">执行一次性插值，当数据改变时，插值处的内容不会更新。</td>
<td>span v-once >这个将不会改变: &lt;/span></td>
</tr>
<tr>
<td>v-html</td>
<td style="text-align:center">输出真正的 HTML</td>
<td>&lt;span v-html=”rawHtml”>&lt;/span></td>
</tr>
</tbody>
</table>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>注册组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 定义名为 todo-item 的新组件</span><br><span class="line">Vue.component(&apos;todo-item&apos;, &#123;</span><br><span class="line">  props:[&apos;todo&apos;]</span><br><span class="line">  template: &apos;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&apos;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//调用组件</span><br><span class="line">&lt;ol id=&apos;app&apos;&gt;</span><br><span class="line">  &lt;!-- 创建一个 todo-item 组件的实例 --&gt;</span><br><span class="line">  &lt;todo-item v-for=&apos;item in grocyList&apos; :todo=&apos;item&apos;&gt;</span><br><span class="line">  &lt;/todo-item&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line"></span><br><span class="line">var data = &#123;</span><br><span class="line">    groceryList: [</span><br><span class="line">        &#123; id: 0, text: &apos;蔬菜&apos; &#125;,</span><br><span class="line">        &#123; id: 1, text: &apos;奶酪&apos; &#125;,</span><br><span class="line">        &#123; id: 2, text: &apos;随便其它什么人吃的东西&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.$data =  data //true</span><br><span class="line"></span><br><span class="line">// $watch 是一个实例方法</span><br><span class="line">app.$watch(&apos;a&apos;, function (newValue, oldValue) &#123;</span><br><span class="line">// 这个回调将在 `app.a` 改变后调用</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>props向子组件传递值，data是组件内部的值，并且需要设置初始值。<br>生命周期钩子有: created、mounted、updated 和 destroyed，<br>不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。因为箭头函数是和父级上下文绑定在一起的，this 不会是如你所预期的 Vue 实例，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。</p>
<p>图示：<br><img src="https://cn.vuejs.org/images/lifecycle.png" alt></p>
<h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><p>计算属性：用来规定复杂逻辑，防止在插值中逻辑太多。<br>调用方法：也可以在表达式中调用方法来达到相同效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">    &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &apos;#example&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &apos;Hello&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        // 计算属性的 getter</span><br><span class="line">        reversedMessage: function () &#123;</span><br><span class="line">        // `this` 指向 vm 实例</span><br><span class="line">            return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 在组件中</span><br><span class="line">    methods: &#123;</span><br><span class="line">        reversedMessage: function () &#123;</span><br><span class="line">            return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>message属性更新，依赖的计算属性也更新了。 Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。</p>
<p>区别：</p>
<ul>
<li><p>计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
</li>
<li><p>每当触发重新渲染时，调用方法将总会再次执行函数。</p>
</li>
</ul>
<p>侦听器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    // 如果 `question` 发生改变，这个函数就会运行</span><br><span class="line">    question: function (newQuestion, oldQuestion) &#123;</span><br><span class="line">      this.answer = &apos;Waiting for you to stop typing...&apos;</span><br><span class="line">      this.debouncedGetAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><p>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p>
<ol>
<li>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue</li>
<li>当你修改数组的长度时，例如：vm.items.length = newLength</li>
</ol>
<p>【解决方法】<br>  第一类问题，不仅更改值，也能触发状态更新（两种方法）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line">或实例方法</span><br><span class="line">vm.$<span class="keyword">set</span>(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure></p>
<p> 第二类：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure></p>
<h2 id="对象更新检测"><a href="#对象更新检测" class="headerlink" title="对象更新检测"></a>对象更新检测</h2><p>由于js的限制，不能检测对象属性的添加或删除。只有实例创建时data中的属性值才是响应式的。如果已经创建了实例，就不能动态创建根级别的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.userProfile, &apos;age&apos;, 27)</span><br><span class="line">vm.$set(vm.userProfile, &apos;age&apos;, 27)</span><br><span class="line"></span><br><span class="line">//赋予多个属性，比如使用 Object.assign() 或 _.extend()。创建一个新的对象，而不是加到原有的对象中</span><br><span class="line">vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123;</span><br><span class="line">    age: 27,</span><br><span class="line">    favoriteColor: &apos;Vue Green&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">warn: <span class="function"><span class="keyword">function</span> (<span class="params">message, event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></span><br><span class="line">    <span class="keyword">if</span> (event) event.preventDefault()</span><br><span class="line">    alert(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件修饰符（ 修饰符是由点开头的指令后缀来表示的。）</p>
<p>.stop<br>.prevent<br>.capture<br>.self<br>.once<br>.passive 滚动事件的默认行为 (即滚动行为) 将会立即触发,而不会等待 <code>onScroll</code> 完成,这其中包含 <code>event.preventDefault()</code> 的情况</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>按键修饰符</p>
<p>.enter<br>.tab<br>.delete (捕获“删除”和“退格”键)<br>.esc<br>.space<br>.up<br>.down<br>.left (鼠标事件)<br>.right<br>.middle</p>
<h2 id="输入绑定"><a href="#输入绑定" class="headerlink" title="输入绑定"></a>输入绑定</h2><p>v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。</p>
<p>.lazy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步：（在“change”时而非“input”时更新）<br>.number 自动将用户的输入值转为数值类型. 这通常很有用，因为即使在 type=”number” 时，HTML 输入元素的值也总会返回字符串。<br>.trim 自动过滤用户输入的首尾空白字符</p>
<h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><p>组件必须只有一个根元素，组件的data必须为一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝。<br>内联：通过事件向父级组件发送消息（$emit方法）,用$event访问到值<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"$emit('enlarge-text', 0.1)"</span>&gt;</span></span><br><span class="line">Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-on:enlarge-text</span>=<span class="string">"postFontSize += $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>若是方法：直接作为第一个参数传入方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">...</span><br><span class="line">v-on:enlarge-text=&quot;onEnlargeText&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    onEnlargeText: function (enlargeAmount) &#123;</span><br><span class="line">        this.postFontSize += enlargeAmount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这个 0.1就直接传到enlargeAmount了</span><br></pre></td></tr></table></figure></p>
<p>用于组件上时，v-model 等价于<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:value</span>=<span class="string">"searchText"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:input</span>=<span class="string">"searchText = $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>全局注册：使用 Vue.component 来创建组件。 这些组件是全局注册的。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (new Vue) 的模板中。全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生。<br>局部注册：通过一个普通的 JavaScript 对象来定义组件，然后在 components 选项中定义你想要使用的组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ComponentA = &#123; /* ... */ &#125;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;</span><br><span class="line">      components: &#123;</span><br><span class="line">            &apos;component-a&apos;: ComponentA,</span><br><span class="line">            &apos;component-b&apos;: ComponentB</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>比如什么输入框等相对通用的元素为基础组件，像element-ui里面一样，为了避免重复import，注册为全局组件。比如基础组件的自动化注册：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> upperFirst <span class="keyword">from</span> <span class="string">'lodash/upperFirst'</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">'lodash/camelCase'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">      <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">      <span class="string">'./components'</span>,</span><br><span class="line">      <span class="comment">// 是否查询其子目录</span></span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">      /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取组件配置</span></span><br><span class="line">      <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取组件的 PascalCase 命名</span></span><br><span class="line">      <span class="keyword">const</span> componentName = upperFirst(</span><br><span class="line">            camelCase(</span><br><span class="line">              <span class="comment">// 剥去文件名开头的 `./` 和结尾的扩展名</span></span><br><span class="line">              fileName.replace(<span class="regexp">/^\.\/(.*)\.\w+$/</span>, <span class="string">'$1'</span>)</span><br><span class="line">            )</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 全局注册组件</span></span><br><span class="line">      Vue.component(</span><br><span class="line">            componentName,</span><br><span class="line">            <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">            <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">            <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">            componentConfig.default || componentConfig</span><br><span class="line">      )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>组件传递的属性值一般会替换掉，但是class 和 style 特性会稍微智能一些，即父传递的和子组件本身的值会被合并起来。<br>如果你不希望组件的根元素继承特性，你可以设置在组件的选项中设置 inheritAttrs: false。<br>可以使用$attrs传递组件的属性。</p>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>注意：跟组件和 prop 不同，事件名不会被用作一个 JavaScript 变量名或属性名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。因此，推荐始终使用 kebab-case 的事件名（使用全小写，然后用短横线连接）。</p>
<p>自定义v-model:</p>
<p>一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-checkbox</span> <span class="attr">v-model</span>=<span class="string">"lovingVue"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>model: {<br>    prop: ‘checked’,  // 代表引用model时的值传入名叫checked的prop中<br>    event: ‘change’   // 代表触发change时，lovingVue 值改变<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;base-checkbox&apos;, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &apos;checked&apos;,</span><br><span class="line">    event: &apos;change&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: Boolean</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;checkbox&quot;</span><br><span class="line">      v-bind:checked=&quot;checked&quot;</span><br><span class="line">      v-on:change=&quot;$emit(&apos;change&apos;, $event.target.checked)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="原生事件"><a href="#原生事件" class="headerlink" title="原生事件"></a>原生事件</h2><p>用 v-on 的 .native 修饰符，在一个组件的根元素上直接监听一个原生事件。<br>不过在你尝试监听一个类似 <code>&lt;input&gt;</code> 的非常特定的元素时，这并不是个好主意。<br>这时，父级的 .native 监听器将静默失败。它不会产生任何报错，但是 onFocus 处理函数不会如你预期地被调用。<br>为了解决这个问题，Vue 提供了一个 $listeners 属性，它是一个对象，里面包含了作用在这个组件上的所有监听器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;base-input&apos;, &#123;</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  props: [&apos;label&apos;, &apos;value&apos;],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListeners: function () &#123;</span><br><span class="line">      var vm = this</span><br><span class="line">      // `Object.assign` 将所有的对象合并为一个新对象</span><br><span class="line">      return Object.assign(&#123;&#125;,</span><br><span class="line">        // 我们从父级添加所有的监听器</span><br><span class="line">        this.$listeners,</span><br><span class="line">        // 然后我们添加自定义监听器，</span><br><span class="line">        // 或覆写一些监听器的行为</span><br><span class="line">        &#123;</span><br><span class="line">          // 这里确保组件配合 `v-model` 的工作</span><br><span class="line">          input: function (event) &#123;</span><br><span class="line">            vm.$emit(&apos;input&apos;, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">      &#123;&#123; label &#125;&#125;</span><br><span class="line">      &lt;input</span><br><span class="line">        v-bind=&quot;$attrs&quot;</span><br><span class="line">        v-bind:value=&quot;value&quot;</span><br><span class="line">        v-on=&quot;inputListeners&quot;</span><br><span class="line">      &gt;</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。<br>为了解决这个问题，我们可以用一个 <keep-alive> 元素将其动态组件包裹起来。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 失活的组件将会被缓存！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure></keep-alive></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li>对于MVVM的理解？<br>MVVM 是 Model-View-ViewModel 的缩写。</li>
</ol>
<ul>
<li>Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。</li>
<li>View 代表UI 组件，它负责将数据模型转化成UI 展现出来。</li>
<li>ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。<br>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。<br>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</li>
</ul>
<ol start="2">
<li>vue的生命周期</li>
</ol>
<ul>
<li>beforeCreate（创建前） 在数据观测和初始化事件还未开始</li>
<li>created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来</li>
<li>beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</li>
<li>mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</li>
<li>beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</li>
<li>updated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li>beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。</li>
<li>destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li>
</ul>
<ol start="3">
<li><p>vue实现双向绑定的原理 Object.defineProperty()<br>采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
</li>
<li><p>Vue组件间的参数传递</p>
</li>
</ol>
<ul>
<li>父组件与子组件传值<br>父组件传给子组件：子组件通过props方法接受数据;<br>子组件传给父组件：$emit方法传递参数</li>
<li>非父子组件间的数据传递，兄弟组件传值<br>eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。</li>
</ul>
<ol start="5">
<li><p>路由实现<br>hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；<br>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。<br>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回" target="_blank" rel="noopener">http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回</a> 404 错误。<br>history模式：history采用HTML5的新特性；且提供了两个新方法：pushState()，replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。<br>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a href="http://www.xxx.com/items/id。后端如果缺少对" target="_blank" rel="noopener">http://www.xxx.com/items/id。后端如果缺少对</a> /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</p>
</li>
<li><p>vue and react and angular<br>与React的区别<br>相同点：<br>React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。<br>不同点：</p>
</li>
</ol>
<ul>
<li>React整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流，推崇结合immutable来实现数据不可变。而vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。<br>react的性能优化需要手动去做，而vue的性能优化是自动的，但是vue的响应式机制也有问题，就是当state特别多的时候，Watcher也会很多，会导致卡顿，所以大型应用（状态特别多的）一般用react，更加可控。</li>
<li>react的思路是all in js，通过js来生成html，所以设计了jsx。vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。</li>
<li>react功能一般交给社区，vue是内置。</li>
</ul>
<ol start="7">
<li><p>vue的路由钩子<br>首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。<br>beforeEach主要有3个参数to，from，next：<br>to：route即将进入的目标路由对象，<br>from：route当前导航正要离开的路由<br>next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。<br>比如我写的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isLogin = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">'cweb-access'</span>) || <span class="built_in">window</span>.localStorage.getItem(<span class="string">'cweb-access-lo'</span>);</span><br><span class="line">  <span class="keyword">const</span> params = &#123;</span><br><span class="line">    searchData: &#123;</span><br><span class="line">      regex: <span class="regexp">/achievement\/data-query/g</span>,</span><br><span class="line">      canEnter: isLogin,</span><br><span class="line">      message: <span class="string">'请先登录。'</span>,</span><br><span class="line">      toUrl: <span class="string">'/login'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    account: &#123;</span><br><span class="line">      regex: <span class="regexp">/account/g</span>,</span><br><span class="line">      canEnter: store.state.selfInfo &amp;&amp; store.state.selfInfo.accountType == <span class="string">'ADMIN'</span>,</span><br><span class="line">      message: <span class="string">'请先登录，或您没有查看系统账号列表的权限。'</span>,</span><br><span class="line">      toUrl: <span class="string">'/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    service: &#123;</span><br><span class="line">      regex: <span class="regexp">/service/g</span>,</span><br><span class="line">      canEnter: isLogin,</span><br><span class="line">      message: <span class="string">'请先登录。'</span>,</span><br><span class="line">      toUrl: <span class="string">'/login'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    selfInfo: &#123;</span><br><span class="line">      regex: <span class="regexp">/selfInfo/g</span>,</span><br><span class="line">      canEnter: isLogin,</span><br><span class="line">      message: <span class="string">'请先登录。'</span>,</span><br><span class="line">      toUrl: <span class="string">'/login'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    modifyPassword: &#123;</span><br><span class="line">      regex: <span class="regexp">/login\/modifyPassword/g</span>,</span><br><span class="line">      canEnter: isLogin,</span><br><span class="line">      message: <span class="string">'请先登录。'</span>,</span><br><span class="line">      toUrl: <span class="string">'/login'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//从编辑或者创建页面退出时应该进行提示</span></span><br><span class="line">  <span class="keyword">if</span>( <span class="keyword">from</span>.path &amp;&amp; <span class="keyword">from</span>.path.match(<span class="regexp">/\/(add)|(edit)/g</span>) &amp;&amp; (!to.path.match(<span class="regexp">/\/(view)/g</span>))) &#123;</span><br><span class="line">    ElementUI.MessageBox.confirm(<span class="string">'返回不能保存已填数据, 是否离开此页面?'</span>, <span class="string">'提示'</span>, &#123;</span><br><span class="line">        type: <span class="string">'info'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 继续的话退出</span></span><br><span class="line"><span class="comment">       * 判断一些模块是否可以访问</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> params) &#123;</span><br><span class="line">          <span class="keyword">let</span> &#123; regex, canEnter, message, toUrl &#125; = params[i];</span><br><span class="line">          <span class="keyword">if</span>( to.path &amp;&amp; to.path.match(regex) &amp;&amp; !canEnter) &#123;</span><br><span class="line">            ElementUI.Message(message);</span><br><span class="line">            next(&#123;</span><br><span class="line">              path: toUrl</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next(); </span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          next(<span class="literal">false</span>);          </span><br><span class="line">      &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断一些模块是否可以访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> params) &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; regex, canEnter, message, toUrl &#125; = params[i];</span><br><span class="line">        <span class="keyword">if</span>( to.path &amp;&amp; to.path.match(regex) &amp;&amp; !canEnter) &#123;</span><br><span class="line">          ElementUI.Message(message);</span><br><span class="line">          next(&#123;</span><br><span class="line">            path: toUrl</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建自定义指令<br>局部指令：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 创建指令(可以多个)</span></span><br><span class="line">    directives: &#123;</span><br><span class="line">        <span class="comment">// 指令名称</span></span><br><span class="line">        dir1: &#123;</span><br><span class="line">            inserted(el) &#123;</span><br><span class="line">                <span class="comment">// 指令中第一个参数是当前使用指令的DOM</span></span><br><span class="line">                <span class="built_in">console</span>.log(el);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">                <span class="comment">// 对DOM进行操作</span></span><br><span class="line">                el.style.width = <span class="string">'200px'</span>;</span><br><span class="line">                el.style.height = <span class="string">'200px'</span>;</span><br><span class="line">                el.style.background = <span class="string">'#000'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>全局指令：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'dir2'</span>, &#123;</span><br><span class="line">    <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">    inserted(el) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(el);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span></span><br><span class="line">    bind(el, binding, vnode, oldVnode) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</span></span><br><span class="line">    update() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    componentUpdated() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    unbind() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<ol start="9">
<li><p>自定义过滤器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        msg:<span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    filters: &#123;</span><br><span class="line">      capitalize: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        value = value.toString()</span><br><span class="line">        <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.filter(<span class="string">'capitalize'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">  value = value.toString()</span><br><span class="line">  <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>keep-alive<br>keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">'include_components'</span> <span class="attr">exclude</span>=<span class="string">'exclude_components'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 该组件是否缓存取决于include和exclude属性 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
  	
					
	  </div>     
	  

	<div class="post-footer">


  <div class="post-footer-other">
       
    
      <span class="post-footer-item">
        <span class="share-btn">
	<span class="iconfont icon-share"></span>
</span>
<div class="-mob-share sildeUpMin">
	<ul class="-mob-inner">
	   			             
        <li class="iconfont 
		icon-share-qq 
		-mob-share-qq 
		-mob-share-link"></li>		
   	   			             
        <li class="iconfont 
		icon-share-weixin 
		-mob-share-weixin 
		-mob-share-link"></li>		
   	   			             
        <li class="iconfont 
		icon-share-weibo 
		-mob-share-weibo 
		-mob-share-link"></li>		
   	   			             
        <li class="iconfont 
		icon-share-douban 
		-mob-share-douban 
		-mob-share-link"></li>		
   	   			             
        <li class="iconfont 
		icon-share-facebook 
		-mob-share-facebook 
		-mob-share-link"></li>		
   	   			             
        <li class="iconfont 
		icon-share-twitter 
		-mob-share-twitter 
		-mob-share-link"></li>		
   	   			             
        <li class="iconfont 
		icon-share-google 
		-mob-share-google 
		-mob-share-link"></li>		
   	   
	</ul>
</div>	


<script id="-mob-share" src="https://f1.webshare.mob.com/code/mob-share.js?appkey=21d601593a1de"></script>
      </span>  
               
  </div>  
    


  <div class="post-footer-meta">
        	

        
          <i class="iconfont icon-tag"></i>     
            <a class="tag-link" href="/tags/vue/">vue</a>    
        	
  </div>

</div>


<nav class="post-footer-nav">
  <div class="post-footer-link">
  
      <a href="/2018/06/02/webpack/" id="post-nav-older" class="post-nav-link-wrap">
        <strong class="post-nav-caption">older</strong>
        
          <a class="post-nav-title" href="/2018/06/02/webpack/">
          webpack的相关概念与使用</a>
      </a>
  
  </div>
  <div class="post-footer-link">
    
        <a href="/2018/07/22/doubleBind/" id="post-nav-newer" class="post-nav-link-wrap">
          <strong class="post-nav-caption">newer</strong>
             
            <a class="post-nav-title" href="/2018/07/22/doubleBind/">
            来来来，走进双向绑定的大门</a>
        </a>
    
  </div>

</nav>
 
	
	
</article>

	<div class="toc-container">
			<div class="toc-sidebar">
			<p class="toc-title">
				Contents
			</p>
			<div class="toc-list">
				<ol class="toc-inner"><li class="toc-inner-item toc-inner-level-1"><a class="toc-inner-link" href="#基本实用"><span class="toc-inner-text">基本实用</span></a><ol class="toc-inner-child"><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#常用表达"><span class="toc-inner-text">常用表达</span></a></li><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#组件化"><span class="toc-inner-text">组件化</span></a></li><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#计算属性和侦听器"><span class="toc-inner-text">计算属性和侦听器</span></a></li><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#数组更新检测"><span class="toc-inner-text">数组更新检测</span></a></li><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#对象更新检测"><span class="toc-inner-text">对象更新检测</span></a></li><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#事件处理"><span class="toc-inner-text">事件处理</span></a></li><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#输入绑定"><span class="toc-inner-text">输入绑定</span></a></li><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#组件基础"><span class="toc-inner-text">组件基础</span></a></li><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#自定义事件"><span class="toc-inner-text">自定义事件</span></a></li><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#原生事件"><span class="toc-inner-text">原生事件</span></a></li><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#动态组件"><span class="toc-inner-text">动态组件</span></a></li><li class="toc-inner-item toc-inner-level-2"><a class="toc-inner-link" href="#常见问题"><span class="toc-inner-text">常见问题</span></a></li></ol></li></ol>
			</div>
		</div>
	</div>

          </div> 
      </div>            
    
    <a id="page-backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="Typing Something here." id="search-input" class="search-input">
            <span class="search-cancel">
                <i class="iconfont icon-cancel">
            </i></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src="/images/favicon.png">  
      

         
            

            <a class="mobile-menu-link" href="/">Home
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">Archives
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">Tags
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">About
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">Search </a>                 
            
         
      
</div>
        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
				
		2017-
		
		2019		
	
		Mooory
		<br>
		Theme Nayo
		</div>			
	 
</footer>
Theme Nayo   

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>