<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>用js获取浏览器位置属性详解(offsetLeft, pageX, clientX, layerX, scrollLeft等等)</title>
      <link href="/2019/02/25/position-attr/"/>
      <content type="html"><![CDATA[<p>在实际运用中，我们经常要获取鼠标点击事件的位置和元素的位置信息。针对页面、浏览器、屏幕，各大厂商也有自己设置的各类属性。所以他们究竟有什么不同呢？哪个属性才是我们想要的呢？</p><h1 id="event属性"><a href="#event属性" class="headerlink" title="event属性"></a>event属性</h1><img src="/images/position_attr_01.png"><p>观察上图，对于X坐标的值，我们一个鼠标事件有clientX，layerX，movementX，offsetX，pageX，screenX，x 多个属性值。它们分别代表什么呢？</p><a id="more"></a><ul><li>screenX 和 screenY<br>鼠标在屏幕上的坐标。screenX,screenY的最大值不会超过屏幕分辨率。作者有两个屏幕，分辨率为1920 * 1080，所以上图点击浏览器的body左上角时，x值为1920。</li><li>clientX 和 clientY<br>相对于浏览器窗口可视区域的X，Y坐标（窗口坐标）,鼠标滚动后原来的起始点就不是起始点，而是以以浏览器滑动条此刻的滑动到的位置为参考点。<img src="/images/position_attr_03.png"></li><li>pageX 和 pageY<br>鼠标在页面上的位置。从页面左上角开始,即是以页面为参考点,不随滑动条移动而变化。IE中不支持，取而代之的是event.x 和 event.y<br>e.pageX = e.clientX + 水平滚动的距离。</li><li>offsetX 和 offsetY<br>offset意为偏移量，是被点击的元素距左上角为参考原点的长度(不包括border), 如果鼠标进入到border区域，为返回负值。</li><li>layerX 和 layerY<img src="/images/position_attr_05.jpg">上图计算公式有点不正确：<br>Chrome: 相对于参考点的长度（包括border）e.layerX = e.offsetX + border-left-width<br>IE: e.layerX = e.pageX</li><li>x 和 y<img src="/images/position_attr_06.jpg"></li></ul><p>浏览器的支持情况如下：<br><img src="/images/position_attr_04.png"></p><hr><h1 id="DOM元素"><a href="#DOM元素" class="headerlink" title="DOM元素"></a>DOM元素</h1><p>前面介绍的event对象的位置属性，而我们的dom元素也有相应的属性。<br><img src="/images/placeholder.png" data-src="/images/position_attr_07.png" class="lazyload"><br><img src="/images/placeholder.png" data-src="/images/position_attr_08.png" class="lazyload"><br><img src="/images/placeholder.png" data-src="/images/position_attr_09.png" class="lazyload"><br>我们绘制了一个正方体，宽高200px，border为5px。</p><ul><li>clientLeft / clientTop<br>元素边框border的大小</li><li>clientWidth / clientHeight<br>元素的可见宽度或高度。等于padding+width</li><li>offsetWidth / offsetHeight<br>元素相对父元素的偏移宽度或高度。等于border+padding+width</li><li>scrollWidth / scrollHeight<br>元素的宽度且包括滚动部分。(不包括border)</li><li>offsetLeft / offsetTop<br>该DOM对象的层级关系中离该对象最近的，设置了position的父对象”中的位置。(从最左最上到对象的border的距离，不包括border)</li><li>scrollLeft / scrollTop<br>置当前横向滚动条的坐标值（已经滚动了多少）<img src="/images/placeholder.png" data-src="/images/position_attr_10.gif" class="lazyload"></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>常见排序算法的原理与实现</title>
      <link href="/2019/02/24/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>本文介绍了冒泡、选择、插入、归并、快速、堆排序等多种排序的原理、js实现和性能表现。希望能把排序算法发光发热！</p><ul><li>冒泡: 将数组相邻元素两两比较大小，一遍一遍把当前最大值（最小值）冒泡到最后。</li><li>选择: 通过数组循环，记录当前最小值（最大值）所在，再与第一个元素进行元素交换，依次类推。</li><li>插入: 对未排序数据中，从已排序序列中从后向前查询，找到相应的位置进行插入。</li><li>归并: 将数组拆分成n个一个元素的数组，再进行两两合并。从底层往上合并时，左右两边的数组都是排序好的，因此合并容易。</li><li>快排: 选择基准元素（一般是中间），所有小于基准的放在左边，大于基准的放在右边，重复直到结束。</li><li>堆排: 初始化堆后，将最后一个元素与堆顶元素交换后，最后元素移出堆排序序列中，再不断调整堆使满足堆的性质。</li></ul><a id="more"></a><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>它的基本思想是：</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>再对最后一位以外的数组，重复前面的过程，直至全部排序完成。</li></ul><p>举例子：</p><blockquote><p>数组为[3,1,4,2], 3和1交换为[1,3,4,2], 第二位的3和4比较不交换，第三位的4和2交换为[1,3,2,4]。第一遍结束后，最后一个值必然是最大的。再重复以上操作，继续排序[1,3,2]数组,依次循环。</p></blockquote><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">//相邻元素两两对比</span></span><br><span class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">//元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li>最佳情况：T(n) = O(n)</li><li>最差情况：T(n) = O(n2)</li><li>平均情况：T(n) = O(n2)</li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="算法简介-1"><a href="#算法简介-1" class="headerlink" title="算法简介"></a>算法简介</h2><p>选择排序（Selection Sort）与冒泡排序类似，也是依次对相邻的数进行两两比较。不同之处在于，它不是每比较一次就调换位置，而是一轮比较完毕，找到最大值（或最小值）之后，将其放在正确的位置，其他数的位置不变。</p><p>举例子：</p><blockquote><p>数组为[3,1,4,2], 先假设第一位3为最小值，当前的最小值为3，与第二位1比较，所以1是最小值。然后最小值与第三位4、第四位2比较，最小值不改变。<br>所以第一位3与最小值1进行交换，数组为[1,3,4,2]。<br>然后比较[3,4,2]数组。依次类推。</p></blockquote><h2 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">//寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">//将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h2><p>表现最稳定的排序算法之一，最佳最差都是O(n²)的时间复杂度。</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="算法简介-2"><a href="#算法简介-2" class="headerlink" title="算法简介"></a>算法简介</h2><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>举例子：</p><blockquote><p>当前未排序数组为[3,1,4,2]，第二位1从已排序好的[3]插入，变为[1,3]。第三位4在[1,3]中插入变成[1,3,4], 第四位2在已排序好的[1,3,4]中排序变成[1,2,3,4]。</p></blockquote><h2 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> preIndex, current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li>最佳情况：输入数组按升序排列。T(n) = O(n)</li><li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li><li>平均情况：T(n) = O(n2)</li></ul><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="算法简介-3"><a href="#算法简介-3" class="headerlink" title="算法简介"></a>算法简介</h2><p>前三种时间复杂度太高，效率低，不适合实际使用。<br>基本思想：将两个已经排序的数组合并，要比从头开始排序所有元素来得快。因此，可以将数组拆开，分成n个只有一个元素的数组，然后不断地两两合并，直到全部排序完成。</p><p>举个例子：</p><blockquote><p>[3,1,4,2]数组分成[3,1]和[4,2]两个部分，[3,1]分为[3]和[1]两部分，再合成[1,3]。同理右边合成了[2,4]。再将两者进行合并为[1,2,3,4]</p></blockquote><h2 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left.length) &#123;</span><br><span class="line">        result = result.concat(left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(right.length) &#123;</span><br><span class="line">        result = result.concat(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h2><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><ul><li>最佳情况：T(n) = O(n)</li><li>最差情况：T(n) = O(nlogn)</li><li>平均情况：T(n) = O(nlogn)</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="算法简介-4"><a href="#算法简介-4" class="headerlink" title="算法简介"></a>算法简介</h2><p>速度快！效率高！是处理大数据最快的排序算法之一。<br>基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><blockquote><p>（1）在数据集之中，选择一个元素作为”基准”（pivot）。<br>（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。<br>（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p></blockquote><h2 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>]; <span class="comment">//获取基准元素的值,同时原数组已经改变了</span></span><br><span class="line">    <span class="keyword">var</span> left = [];</span><br><span class="line">    <span class="keyword">var</span> right = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(pivot, quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h2><blockquote><p>快速排序的最坏运行情况是O(n²)，比如说顺序数列的快排。但它的平摊期望时间是O(n log n) ，且O(n log n)记号中隐含的常数因子很小，比复杂度稳定等于O(n log n)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p></blockquote><ul><li>最佳情况：T(n) = O(nlogn)</li><li>最差情况：T(n) = O(n2)</li><li>平均情况：T(n) = O(nlogn)</li></ul><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="算法简介-5"><a href="#算法简介-5" class="headerlink" title="算法简介"></a>算法简介</h2><p>利用堆的概念来排序的选择排序。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列</li></ol><p>将待排序列构造成一个大顶堆(或小顶堆)，整个序列的最大值(或最小值)就是堆顶的根结点，将根节点的值和堆数组的末尾元素交换，此时末尾元素就是最大值(或最小值)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值(或次小值)，如此反复执行，最终得到一个有序序列。</p><h2 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h2><ol><li>根据数组元素构建一个完成二叉树</li><li>初始化大顶推（使父节点值大于子节点的值，从父节点、左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换, 从下往上进行比较交换）</li><li>将堆的根节点（初始化后为当前二叉树的最大元素）与最后一个元素交换，同时把当前这个最大元素去除堆元素排序之外，堆的数量减一。</li><li>因为交换了元素后，很大可能不满足堆的性质了。从堆顶往下进行调整（使父节点值大于子节点的值，从父节点、左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换, 从上往下进行交换）使堆满足堆的性质。重复3、4步骤，直到结束。</li></ol><p>具体的流程图可以参考：<a href="http://www.cnblogs.com/0zcl/p/6737944.html" target="_blank" rel="noopener">http://www.cnblogs.com/0zcl/p/6737944.html</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> heapSize = arr.length, temp;</span><br><span class="line">    <span class="comment">//建堆,初始化堆</span></span><br><span class="line">    <span class="comment">//length / 2 - 1是二叉树中最后一个非叶子结点的序号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i =  <span class="built_in">Math</span>.floor(heapSize/<span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i, heapSize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = heapSize - <span class="number">1</span>; j &gt;= <span class="number">1</span> ; j--) &#123;</span><br><span class="line">        <span class="comment">//将最后一个元素与堆顶元素交换</span></span><br><span class="line">        temp = arr[j];</span><br><span class="line">        arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = temp;</span><br><span class="line">        heapify(arr, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, i, len</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//l,r是当前节点的左右孩子节点</span></span><br><span class="line">    <span class="comment">//当前节点的下标保存在largest中</span></span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">2</span>*i + <span class="number">1</span>, r = <span class="number">2</span>*i + <span class="number">2</span>, largest = i, temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">        <span class="comment">//左节点大于父节点</span></span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">        <span class="comment">//右节点在父节点、左孩子节点中更大</span></span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若i处的值比其左右孩子结点的值小，就将其和最大值进行交换</span></span><br><span class="line">    <span class="keyword">if</span>(largest != i) &#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line">        <span class="comment">// 交换后再查看剩下的堆是否满足堆的性质（以前满足）</span></span><br><span class="line">        heapify(arr, largest, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h2><p>参考：<a href="https://juejin.im/entry/5883501a128fe10065daaeb0" target="_blank" rel="noopener">https://juejin.im/entry/5883501a128fe10065daaeb0</a></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用html5拖放或绑定鼠标事件实现移动元素功能</title>
      <link href="/2018/01/02/%E4%BD%BF%E7%94%A8html5%E6%8B%96%E6%94%BE%E6%88%96%E7%BB%91%E5%AE%9A%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E5%85%83%E7%B4%A0%E5%8A%9F%E8%83%BD/"/>
      <content type="html"><![CDATA[<p>要实现一个点击元素，拖动元素到页面上你想要在的地方。如何实现这个功能呢？我想到了两种实现方法：第一种就是最近学习的html5的drag和drop功能；第二种是绑定鼠标的onmousedown，onmousemove事件。然后这两种实现方式又有什么区别呢？</p><a id="more"></a><h1 id="普通鼠标事件"><a href="#普通鼠标事件" class="headerlink" title="普通鼠标事件"></a>普通鼠标事件</h1><p>我们把body中的div元素设定为我们要移动的元素，移动的位置整个页面。这种鼠标事件的响应周期是350毫秒。具体实现如下：</p><ul><li>鼠标点击下时，计算鼠标点击的位置距离DIV左边和上边的距离</li><li>鼠标移动时，计算处DIV元素左上角是否在页面可以移动的区域内</li><li>合理设置DIV的top和left值，实现元素跟随鼠标移动的功能。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>实现鼠标拖放<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        div&#123;</span></span><br><span class="line"><span class="undefined">        position: absolute;</span></span><br><span class="line"><span class="undefined">        width: 200px;</span></span><br><span class="line"><span class="undefined">        height: 200px;</span></span><br><span class="line"><span class="undefined">        background: #369</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 鼠标点击的位置距离DIV左边的距离 </span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> disX = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 鼠标点击的位置距离DIV顶部的距离</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> disY = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    oDiv.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="undefined">        disX = e.clientX - oDiv.offsetLeft;</span></span><br><span class="line"><span class="undefined">        disY = e.clientY- oDiv.offsetTop;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 横轴坐标</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> leftX = e.clientX - disX;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 纵轴坐标</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> topY =e.clientY - disY;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>( leftX &lt; <span class="number">0</span> )&#123;</span></span><br><span class="line"><span class="undefined">                leftX = 0;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 获取浏览器视口大小 document.document.documentElement.clientWidth</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">else</span> <span class="keyword">if</span>(  leftX &gt; <span class="built_in">document</span>.documentElement.clientWidth - oDiv.offsetWidth )&#123;</span></span><br><span class="line"><span class="javascript">                leftX = <span class="built_in">document</span>.documentElement.clientWidth - oDiv.offsetWidth;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>( topY &lt; <span class="number">0</span> )&#123;</span></span><br><span class="line"><span class="undefined">                topY = 0;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">else</span> <span class="keyword">if</span>( topY &gt; <span class="built_in">document</span>.documentElement.clientHeight -oDiv.offsetHeight )&#123;</span></span><br><span class="line"><span class="javascript">                topY = <span class="built_in">document</span>.documentElement.clientHeight - oDiv.offsetHeight;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            oDiv.style.left = leftX + <span class="string">"px"</span>;</span></span><br><span class="line"><span class="javascript">            oDiv.style.top = topY+<span class="string">"px"</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"> &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="利用html5的drag和drop功能"><a href="#利用html5的drag和drop功能" class="headerlink" title="利用html5的drag和drop功能"></a>利用html5的drag和drop功能</h1><p>重点是:</p><ul><li>要移动元素的draggable属性必须为true</li><li>dragover默认浏览器效果是drop失效，所以必须阻止默认事件。</li><li>dragover事件必须用addEventListener绑定，否则不生效。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSONP实现跨域2<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        div&#123;</span></span><br><span class="line"><span class="undefined">        position: absolute;</span></span><br><span class="line"><span class="undefined">        width: 200px;</span></span><br><span class="line"><span class="undefined">        height: 200px;</span></span><br><span class="line"><span class="undefined">        background: #369</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">'true'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//第一种方法</span></span></span><br><span class="line"><span class="javascript"> <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//获取被拖拽元素</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> item = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="comment">//鼠标点击的位置离div左边和上边的距离，现在设置为0</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> disX = <span class="number">0</span>, disY = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//div在页面上的位置。</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> leftX = <span class="number">0</span>, topY = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    item.ondragstart = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> e = event || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//记录鼠标点击位置和div的距离,鼠标当前位置剪去div离body的位置</span></span></span><br><span class="line"><span class="undefined">        disX = e.clientX - item.offsetLeft;</span></span><br><span class="line"><span class="undefined">        disY = e.clientY - item.offsetTop;</span></span><br><span class="line"><span class="javascript">        event.dataTransfer.effectAllowed = <span class="string">'all'</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    item.ondragend = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> e = event || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="undefined">        leftX = e.clientX - disX;</span></span><br><span class="line"><span class="undefined">        topY = e.clientY - disY;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(leftX &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="undefined">            leftX = 0;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftX &gt; <span class="built_in">document</span>.documentElement.clientWidth - item.offsetWidth) &#123;</span></span><br><span class="line"><span class="javascript">            leftX = <span class="built_in">document</span>.documentElement.clientWidth - item.offsetWidth;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (topY &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="undefined">            topY = 0;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (topY &gt; <span class="built_in">document</span>.documentElement.clientHeight - item.offsetHeight) &#123;</span></span><br><span class="line"><span class="javascript">            topY = <span class="built_in">document</span>.documentElement.clientHeight - item.offsetHeight;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        item.style.left = leftX + <span class="string">"px"</span>;</span></span><br><span class="line"><span class="javascript">        item.style.top = topY + <span class="string">"px"</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">"dragover"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        event.preventDefault();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// event.dataTransfer.dropEffect = 'link';</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>这两种实现方式究竟有什么区别？当然让你自己去尝试一下啦。<br>总之，第一种实现的效果元素跟随，第二种被拖动元素在没有放下前一直在原位置有占位，同时跟随鼠标的效果是半透明的。<br><img src="/images/drag_01.png"></p>]]></content>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记录markdown的相关语法</title>
      <link href="/2017/08/13/markdown/"/>
      <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>我是正文</p><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><a id="more"></a><hr><blockquote><p>这也是引用块</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是代码段</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ss</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'str'</span>);</span><br></pre></td></tr></table></figure><!-- 这里是获取资源文件夹下面的图片，普通的用souce文件夹下面的资源 --><img src="/images/timg2.jpg"><p>来源：<a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p><ul><li>无序列表第一层<ul><li>这里是说明</li><li>第二层</li></ul></li><li>无序列表</li></ul><ol><li>有序列表</li><li>序号和内容之间要有空格</li></ol><table><thead><tr><th>语句</th><th style="text-align:center">说明</th><th style="text-align:right">备注</th></tr></thead><tbody><tr><td>hello</td><td style="text-align:center">你好</td><td style="text-align:right">英文</td></tr></tbody></table>]]></content>
      
      
    </entry>
    
  
  
</search>
